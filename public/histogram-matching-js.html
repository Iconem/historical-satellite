<html>
  <head>
    <style>
body {
  font-family: "Roboto", sans-serif;
}
.flex-grid {
  display: flex;
}
.col {
  flex: 1;
  padding: 10px;
  text-align: center;
}
.flex-grid-thirds {
  display: flex;
  justify-content: space-between;
}
.flex-grid-thirds .col {
  width: 32%;
}
.col img, .col canvas {
  max-width: 100%;
}
    </style>
  </head>
  <body>
    <div style="padding: 30px; ">
      <h3>Pure JS Histogram Matching - client-side</h3>
      <p>
Inspired by <a href="https://github.com/mapbox/rio-hist/issues/3">mapbox/rio-hist</a> (python), this demo showcases pure-JS Histogram Matching. <br/>Implementation based on scikit-image (<a href="https://scikit-image.org/docs/stable/auto_examples/color_exposure/plot_histogram_matching.html">doc</a> and <a href="https://github.com/scikit-image/scikit-image/blob/v0.25.2/skimage/exposure/histogram_matching.py#L33-L93">code</a>) which simply relies on numpy <code>bincount, cumsum, interp</code>. <br/>scikit-image and numpy use BSD3 License. 
      </p>
    </div>
    <div class="flex-grid-thirds">
      <div class="col"> SOURCE <input type="file" id="source-input" accept="image/png, image/jpeg" /> </div> 
      <!-- onChange="onChangeInput(this)" -->
      <div class="col"> TARGET <input type="file" id="target-input" accept="image/png, image/jpeg" /> </div>
      <div class="col"> MATCHED OUTPUT </div>
    </div>
    <div class="flex-grid-thirds">
      <div class="col" id="source-img-div"></div>
      <div class="col" id="target-img-div"></div>
      <div class="col" id="matched-img-div"></div>
    </div>

    <script type="module">
// Implement histogram matching, heavily inspired by scikit-image 
// // See [doc](https://scikit-image.org/docs/stable/auto_examples/color_exposure/plot_histogram_matching.html) and [histogram_matching.py](https://github.com/scikit-image/scikit-image/blob/v0.25.2/skimage/exposure/histogram_matching.py#L33-L93
// Relies on numpy bincount, cumsum, interp, reimplemented below with some assumptions

const img_objs = [];
let source_filepath = './source1.jpg';
let target_filepath = './reference1.jpg';


// Compute histogram bins for an array, with optional min/max for faster compute, and optional normalization parameter
export function bincount(arr, binCount, min, max, normalize = false) {
  if (min === undefined) min = Math.min(...arr);
  if (max === undefined) max = Math.max(...arr);

  let bins = new Uint32Array(binCount);
  for (let i = 0; i < arr.length; i++) {
    // Clamping not needed under the assumption items do not exceed min-max range, otherwise will overflow
    const bin = (arr[i] - min) * (binCount - 1) / (max - min);
    bins[Math.floor(bin)]++;
  }
  if (normalize) 
    bins = Float64Array.from(bins, b => b / arr.length); 
  
  return bins;
}

// cumulative sum of array
export function cumsum(arr) {
  const n = arr.length;
  const out = new Float64Array(n);
  let s = 0;
  for (let i = 0; i < n; i++) {
    s += arr[i];
    out[i] = s;
  }
  return out;
}

// That one is a bit tricky, https://numpy.org/doc/stable/reference/generated/numpy.interp.html
export function interp(x, xp, fp) {
  const out = new Float64Array(x.length);

  for (let i = 0; i < x.length; i++) {
    const xi = x[i];

    // left of xp[0] → clamp
    if (xi <= xp[0]) {
      out[i] = fp[0];
      continue;
    }

    // right of xp[-1] → clamp
    if (xi >= xp[xp.length - 1]) {
      out[i] = fp[fp.length - 1];
      continue;
    }

    // binary search would be faster, but linear scan is fine
    let j = 1;
    while (xi > xp[j]) j++;

    const x0 = xp[j - 1], x1 = xp[j];
    const y0 = fp[j - 1], y1 = fp[j];
    const t = (xi - x0) / (x1 - x0);
    out[i] = y0 + t * (y1 - y0);
  }

  return out;
}

// helper for uint8 histograms
function getNormalizedCdfUint8(arr) {
  return cumsum(bincount(arr, 256, 0, 255, true));
}

// compute mapping between source and target
export function matchCumulativeCdf(source, target) {
  const srcCdf = getNormalizedCdfUint8(source);
  const tgtCdf = getNormalizedCdfUint8(target);
  const values = Array.from({ length: 256 }, (_, i) => i);

  // For each source intensity, find the CDF value, then find which target intensity has the closest CDF value.
  return interp(srcCdf, tgtCdf, values);
}

// ------------------- high-level API -------------------

/**
 * Match histograms of two raw JS images.
 * Works for grayscale, RGB, or RGBA.
 * BEWARE RETURNED MAPPINGS IS NOT A FUNCTION THAT TAKES FLOAT, BUT AN ARRAY LOOKUP TABLE, CAN ONLY TAKE INTEGER VALUES
 *
 * @param {Uint8Array} source - Source image array (flat 1D, 1/3/4 channels interleaved).
 * @param {Uint8Array} target - Target image array (same shape/channels as source).
 * @param Number channels - count of channels to do correct de-interleaving of RGB channels values.
 * @param {'MAPPING'|'MATCHED_DATA'} returnType - Whether to return mappings or matched data.
 * @returns {{mappings: Float64Array[], matched?: Uint8Array}}
 */
export function matchHistograms(source, target, channels = 3, returnType = 'MATCHED_DATA') {
//   const channels = source.length % 4 === 0 ? 4 :
//                    source.length % 3 === 0 ? 3 : 1;
  // RGB / RGBA
  const mappings = [];
  for (let c = 0; c < Math.min(3, channels); c++) {
      const srcChannel = [];
      const tgtChannel = [];
      for (let i = c; i < source.length; i += channels) srcChannel.push(source[i]);
      for (let i = c; i < target.length; i += channels) tgtChannel.push(target[i]);
      mappings[c] = matchCumulativeCdf(srcChannel, tgtChannel);
  }
  console.log('mappings', mappings)

  if (returnType === 'MAPPING') return {mappings};
  const out = new Uint8Array(source.length);
  for (let i = 0; i < source.length; i += channels) {
    for (let c = 0; c < 3; c++) {
      out[i + c]     = mappings[0 + c][source[i + c]];
    }
    if (channels === 4) out[i + 3] = source[i + 3]; // keep alpha
  }
  return {mappings, matched: out};
}



function newImageWithOnload(filepath) {
  const img = new Image(); 
  img.onload = function() {
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);
    img_objs.push({ filepath, ctx, img, canvas });

    if (img_objs.length === 2) {
      const source = img_objs.find(i => i.filepath === source_filepath);
      const target = img_objs.find(i => i.filepath === target_filepath);
      console.log('source', source, target)

      const source_arr = source.ctx.getImageData(0, 0, source.canvas.width, source.canvas.height);
      const target_arr = target.ctx.getImageData(0, 0, target.canvas.width, target.canvas.height);
      console.log('source_arr', source_arr, target_arr)

      const start = Date.now();
      const returnType = 'MATCHED_DATA'
      const channels = 3 // should be computed from image, or getImageData is always same type?
      const matched = matchHistograms(source_arr.data, target_arr.data, channels, returnType);
      console.log('matched', matched, 'mappings slice')
      console.log(matched.mappings[0].slice(0, 30))
      const elapsed_ms = Date.now() - start

      // Render matched image
      const canvas_out = document.createElement("canvas");
      canvas_out.width = source.img.width;
      canvas_out.height = source.img.height;
      const ctx_out = canvas_out.getContext("2d");
      const imageData = ctx_out.createImageData(canvas_out.width, canvas_out.height);
      imageData.data.set(matched.matched);
      ctx_out.putImageData(imageData, 0, 0);
      
      container = document.getElementById('matched-img-div');

      const stats_div = document.createElement("div");
      const statsObj = {
        source: {
          width: source.img.width, 
          height: source.img.height,
          Mpix: Math.floor(source.img.width * source.img.height / 1000000),
        }, 
        target: {
          width: target.img.width, 
          height: target.img.height,
          Mpix: Math.floor(target.img.width * target.img.height / 1000000),
        }, 
        timings: {
          ms: elapsed_ms
        }
      }
      stats_div.innerHTML = JSON.stringify(statsObj, null, " ");

      // container.replaceChildren(canvas_out);
      canvas_out.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const img = document.createElement("img");
        img.src = url;
        container.replaceChildren(img);

        container.addChildren(stats_div)
      }, "image/png");
    }
  }
  img.src = filepath;
  let container
  if (filepath === source_filepath) 
    container = document.getElementById('source-img-div');
  else 
    container = document.getElementById('target-img-div');
  container.replaceChildren(img);
}

let img_source = newImageWithOnload(source_filepath)
let img_target = newImageWithOnload(target_filepath)
console.log('done loading image, will start processing callbacks to compute Histogram Matching')


let obj
function onChangeInput (event) {
  console.log(event)
  const target = event.target
  const srcId = target.id
  console.log(srcId)
  if (srcId == 'source-input') {
      obj = img_objs.find(i => i.filepath === source_filepath);
      source_filepath = target.value
      console.log('source-input')
  } else if (srcId == 'target-input') {
      obj = img_objs.find(i => i.filepath === target_filepath);
      target_filepath = target.value
      console.log('target-input')
  }
  console.log(obj, source_filepath, target_filepath)
  var file = target.files[0];
  console.log(file)
  var reader  = new FileReader();
  reader.onloadend = function () {
    console.log('loadend')
    obj.img.src = reader.result;
    console.log('end of loadend')
  }
  if (file) {
    console.log('readAsDataURL', file);
    reader.readAsDataURL(file);
    console.log('readAsDataURL done');
  } else {
    preview.src = "";
  }
};
window.onChangeInput = onChangeInput
document.getElementById('source-input').onchange = onChangeInput
document.getElementById('target-input').onchange = onChangeInput

</script>

</body>
</html>