<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
    <style>
body {
  font-family: "Roboto", sans-serif;
}
.flex-grid {
  display: flex;
}
.col {
  flex: 1;
  padding: 10px;
  text-align: center;
}
.flex-grid-thirds {
  display: flex;
  justify-content: space-between;
}
.flex-grid-thirds .col {
  width: 32%;
}
.col img, .col canvas {
  max-width: 100%;
}
    </style>
  </head>
  <body>
    <div style="padding: 30px; ">
      <h3>Pure JS, client-side, Histogram Matching</h3>
      <p>
Inspired by <a href="https://github.com/mapbox/rio-hist/issues/3">mapbox/rio-hist</a> (python), this demo showcases pure-JS Histogram Matching. <br/>Implementation based on scikit-image (<a href="https://scikit-image.org/docs/stable/auto_examples/color_exposure/plot_histogram_matching.html">doc</a> and <a href="https://github.com/scikit-image/scikit-image/blob/v0.25.2/skimage/exposure/histogram_matching.py#L33-L93">code</a>) which simply relies on numpy <code>bincount, cumsum, interp</code>. <br/>scikit-image and numpy use BSD3 License. 
      </p>
    </div>
    <div class="flex-grid-thirds">
      <div class="col"> SOURCE <input type="file" id="source-input" accept="image/png, image/jpeg" /> </div> 
      <!-- onChange="onChangeInput(this)" -->
      <div class="col"> TARGET <input type="file" id="target-input" accept="image/png, image/jpeg" /> </div>
      <div class="col"> MATCHED OUTPUT </div>
    </div>
    <div class="flex-grid-thirds">
      <div class="col" id="source-img-div"></div>
      <div class="col" id="target-img-div"></div>
      <div class="col" id="matched-img-div"></div>
    </div>

    <script type="module">
// Implement histogram matching, heavily inspired by scikit-image 
// // See [doc](https://scikit-image.org/docs/stable/auto_examples/color_exposure/plot_histogram_matching.html) and [histogram_matching.py](https://github.com/scikit-image/scikit-image/blob/v0.25.2/skimage/exposure/histogram_matching.py#L33-L93
// Relies on numpy bincount, cumsum, interp, reimplemented below with some assumptions


// Compute histogram bins for an array, with optional min/max for faster compute, and optional normalization parameter
export function bincount(arr, binCount, min, max, normalize = false) {
  if (min === undefined) min = Math.min(...arr);
  if (max === undefined) max = Math.max(...arr);

  let bins = new Uint32Array(binCount);
  for (let i = 0; i < arr.length; i++) {
    // Clamping not needed under the assumption items do not exceed min-max range, otherwise will overflow
    const bin = (arr[i] - min) * (binCount - 1) / (max - min);
    bins[Math.floor(bin)]++;
  }
  if (normalize) 
    bins = Float64Array.from(bins, b => b / arr.length); 
  
  return bins;
}

// cumulative sum of array
export function cumsum(arr) {
  const n = arr.length;
  const out = new Float64Array(n);
  let s = 0;
  for (let i = 0; i < n; i++) {
    s += arr[i];
    out[i] = s;
  }
  return out;
}

// That one is a bit tricky, https://numpy.org/doc/stable/reference/generated/numpy.interp.html
export function interp(x, xp, fp) {
  const out = new Float64Array(x.length);

  for (let i = 0; i < x.length; i++) {
    const xi = x[i];

    // left of xp[0] → clamp
    if (xi <= xp[0]) {
      out[i] = fp[0];
      continue;
    }

    // right of xp[-1] → clamp
    if (xi >= xp[xp.length - 1]) {
      out[i] = fp[fp.length - 1];
      continue;
    }

    // binary search would be faster, but linear scan is fine
    let j = 1;
    while (xi > xp[j]) j++;

    const x0 = xp[j - 1], x1 = xp[j];
    const y0 = fp[j - 1], y1 = fp[j];
    const t = (xi - x0) / (x1 - x0);
    out[i] = y0 + t * (y1 - y0);
  }

  return out;
}

// helper for uint8 histograms
function getNormalizedCdfUint8(arr) {
  const bincounts = bincount(arr, 256, 0, 255, true)
  const cdf = cumsum(bincounts)
  return { bincounts, cdf };
}

// compute mapping between source and target by matching cumulative density functions
export function matchCdf(source, target) {
  const srcCdf = getNormalizedCdfUint8(source);
  const tgtCdf = getNormalizedCdfUint8(target);
  const values = Array.from({ length: 256 }, (_, i) => i);
  const mapping = interp(srcCdf.cdf, tgtCdf.cdf, values)

  // For each source intensity, find the CDF value, then find which target intensity has the closest CDF value.
  return {
    mapping, 
    srcHist: srcCdf.bincounts, 
    tgtHist: tgtCdf.bincounts
  };
}

// ------------------- high-level API -------------------

/**
 * Match histograms of two raw JS images.
 * Works for grayscale, RGB, or RGBA.
 * BEWARE RETURNED MAPPINGS IS NOT A FUNCTION THAT TAKES FLOAT, BUT AN ARRAY LOOKUP TABLE, CAN ONLY TAKE INTEGER VALUES
 *
 * @param {Uint8Array} source - Source image array (flat 1D, 1/3/4 channels interleaved).
 * @param {Uint8Array} target - Target image array (same shape/channels as source).
 * @param {Number} channels - count of channels to do correct de-interleaving of RGB channels values.
 * @param {'MAPPING'|'MATCHED_DATA'} returnType - Whether to return mappings or matched data.
 * @param {Number} maxMpx - Whether to subsample/apply downscaling to source/target image rasters If pixelCount > maxMpx. 1 = 100% res, 2 = 2x downsampling/subsampling
 * @returns {{mappings: Float64Array[], matched?: Uint8Array}}
 */
export function matchHistograms(source, target, channels = 3, returnType = 'MATCHED_DATA', maxMpx=-1) {
  // Downsample source and target arrays in case they exceed user-defined maxMpx param
  let srcDownsample = 1, tgtDownsample = 1;
  if (maxMpx > 0) {
    // srcDownsample = Math.max(1, Math.ceil((source.length / channels / 1e6) / maxMpx))
    // tgtDownsample = Math.max(1, Math.ceil((source.length / channels / 1e6) / maxMpx))
    srcDownsample = Math.ceil((source.length / channels / 1e6) / maxMpx)
    tgtDownsample = Math.ceil((source.length / channels / 1e6) / maxMpx)
    console.log('Downsampling factors', srcDownsample, tgtDownsample)
  }

  // RGB / RGBA
  const mappings = [];
  for (let c = 0; c < Math.min(3, channels); c++) {
      const srcChannel = [];
      const tgtChannel = [];
      for (let i = c; i < source.length; i += channels * srcDownsample) srcChannel.push(source[i]);
      for (let i = c; i < target.length; i += channels * tgtDownsample) tgtChannel.push(target[i]);
      mappings[c] = matchCdf(srcChannel, tgtChannel);
  }
  console.log('mappings', mappings)

  if (returnType === 'MAPPING') return {mappings};
  const out = new Uint8Array(source.length);
  for (let i = 0; i < source.length; i += channels) {
    for (let c = 0; c < 3; c++) {
      out[i + c] = mappings[0 + c].mapping[source[i + c]];
    }
    if (channels === 4) out[i + 3] = source[i + 3]; // keep alpha
  }
  return {mappings, matched: out};
}

// Helper function to display chartjs histograms
// CDNs like jsDelivr, cdnjs serve .esm.js files with text/plain or text/html instead of application/javascript, yielding browser blocking remote ESM imports
// import { Chart } from "https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.esm.js";
function renderHistogram(histData, domElement) {
  const commonLineOpts = {
      fill: true,
      // pointStyle: false,
      pointRadius: 0,
      borderWidth: 1,
  }
  // Hide legend, tooltip, ticks but display grid with given stepSize
  const histChartOpts = {
      plugins: { 
        title: { display: true, text: 'Histogram'}, 
        legend: { display: false }, 
        tooltip: { enabled: false }
      },
      scales: {
        x: {
          type: 'linear',   
          ticks: { display: false, stepSize: 50 },
          grid: { display: true },
        },
        y: {
          type: 'linear',
          ticks: { display: false, stepSize: 0.005 },
          grid: { display: true }, 
        }
      }
    }
  return new Chart(
    domElement, {
    type: 'line',
    data: {
      labels: Array.from({length: histData.R.length}, (_, i) => i),
      datasets: [
        {
          data: histData.R,
          borderColor: 'rgba(255,0,0,0.8)',
          backgroundColor: 'rgba(255,0,0,0.15)',
          ...commonLineOpts
        },
        {
          data: histData.G,
          borderColor: 'rgba(0,255,0,0.8)',
          backgroundColor: 'rgba(0,255,0,0.15)',
          ...commonLineOpts
        },
        {
          data: histData.B,
          borderColor: 'rgba(0,0,255,0.8)',
          backgroundColor: 'rgba(0,0,255,0.15)',
          ...commonLineOpts
        }
      ]
    },
    options: histChartOpts
  });
}

// Example usage: call after computing histograms
// histData = { R: [...256 bins...], G: [...], B: [...] }

// --- image handling ---
const img_objs = {};
// slot is source or target, indexing img_objs, mapped to input and img slot+"-img-div
function loadImage(fileOrUrl, slot, maxMpx=-1) { // TODO 2 is for testing default downscale = 1
  const img = new Image();
  img.onload = function() {
    const canvas = document.createElement("canvas");
    // naturalWidth / downscale to make canvas smaller and downsample naturally, downscale = 2 is nicer, but then would need to use source input and re-apply mapping, so passed source resolution instead
    canvas.width = img.naturalWidth;   // naturalWidth instead of width
    canvas.height = img.naturalHeight; // naturalHeight instead of height
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0); // rescale image
    // ctx.drawImage(img, 0, 0, canvas.width, canvas.height); // rescale image

    img_objs[slot] = {ctx, img, canvas};
    document.getElementById(slot+"-img-div").replaceChildren(img);

    if (img_objs.source && img_objs.target) {
      // Get source and target arrays from dom imgs
      const source_canvas = img_objs.source.canvas
      const target_canvas = img_objs.target.canvas
      const sourceArr = img_objs.source.ctx.getImageData(0,0,source_canvas.width,source_canvas.height).data;
      const targetArr = img_objs.target.ctx.getImageData(0,0,target_canvas.width,target_canvas.height).data;

      // Match Histograms Computation
      // Check getImageData always return 4 channels RGBA 
      const start = Date.now();
      const matched = matchHistograms(sourceArr, targetArr, 4, 'MATCHED_DATA', maxMpx);
      const elapsed_ms = Date.now() - start

      // Write matched image to outCanvas
      const outCanvas = document.createElement("canvas");
      outCanvas.width = source_canvas.width;
      outCanvas.height = source_canvas.height;
      const ctxOut = outCanvas.getContext("2d");
      const outData = ctxOut.createImageData(outCanvas.width, outCanvas.height);
      outData.data.set(matched.matched);
      ctxOut.putImageData(outData, 0, 0);

      // Display to user and log stats
      const container = document.getElementById('matched-img-div');
      console.log('matched', matched, 'mappings slice')
      console.log(matched.mappings[0].mapping.slice(0, 30))

      const stats_div = document.createElement("pre");
      const sourceMpix = (img_objs.source.canvas.width * img_objs.source.canvas.height / 1e6).toFixed(2)
      const targetMpix = (img_objs.target.canvas.width * img_objs.target.canvas.height / 1e6).toFixed(2)
      stats_div.textContent = `Histogram matching took ${elapsed_ms}ms\nSource: ${sourceMpix}Mpx (${img_objs.source.canvas.width} x ${img_objs.source.canvas.height})\nTarget: ${targetMpix}Mpx (${img_objs.target.canvas.width} x ${img_objs.target.canvas.height})` 
      stats_div.style = 'text-align: left; padding: 20px;'

      // Add histograms charts to divs
      const srcHistData= {R: matched.mappings[0].srcHist, G: matched.mappings[1].srcHist, B: matched.mappings[2].srcHist}
      const tgtHistData= {R: matched.mappings[0].tgtHist, G: matched.mappings[1].tgtHist, B: matched.mappings[2].tgtHist}
      const srcHistCanvas = document.createElement("canvas");
      const srcHistChart = renderHistogram(srcHistData, srcHistCanvas) 
      document.getElementById("source-img-div").appendChild(srcHistCanvas);
      const tgtHistCanvas = document.createElement("canvas");
      const tgtHistChart = renderHistogram(tgtHistData, tgtHistCanvas) 
      document.getElementById("target-img-div").appendChild(tgtHistCanvas);
      

      // Add output to DOM as image rather than canvas
      // container.replaceChildren(outCanvas);
      outCanvas.toBlob(function(blob) {
        // Add image resulting from histogram matching to output div
        const url = URL.createObjectURL(blob);
        const img = document.createElement("img");
        img.src = url;
        container.replaceChildren(img);

        // Also show some stats
        container.appendChild(stats_div);
      }, "image/png");

    }
  };
  img.src = fileOrUrl;
}

function handleInputChange(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  // reader.onload = ev => loadImage(ev.target.result, e.target.id.split("-")[0]);
  reader.onload = ev => loadImage(ev.target.result, e.target.id.includes('source') ? 'source' : 'target');
  reader.readAsDataURL(file);
}

document.getElementById("source-input").addEventListener("change", handleInputChange);
document.getElementById("target-input").addEventListener("change", handleInputChange);

// preload defaults
let source_filepath = './source1.jpg';
let target_filepath = './reference1.jpg';

loadImage(source_filepath, "source");
loadImage(target_filepath, "target");

</script>

</body>
</html>